---
tags: antlr
---
These notes made trying to figure out how to use the [[C language target]] with the [[ANTLR]] prerelease (prior to the release of [[ANTLR 3.0]]). With the official 3.0 release extensive examples for the [[C language target]] were made available, rendering these notes largely redundant. See [[C language target]] for the most up-to-date information.

= Grammar setup =

Specify the target language in the <tt>options</tt> block:

<pre>grammar Walrus;
options { language = C; }</pre>

= <tt>CLASSPATH</tt> =

To run [[ANTLR]] from the [[command line]] you must set up the <tt>CLASSPATH</tt> environment variable correctly. For example, on my system where [[ANTLR]] 3.0b7 is installed under <tt>/usr/local/</tt> I have the following in my <tt>CLASSPATH</tt>:

* <tt>/usr/local/antlr/lib/antlr-3.0b7.jar</tt>
* <tt>/usr/local/antlr/lib/antlr-2.7.7.jar</tt>
* <tt>/usr/local/antlr/lib/stringtemplate-3.0.jar</tt>

I set this in my [[Bash]] shell with the following command:

<pre># split across two lines for readability
export CLASSPATH="/usr/local/antlr/lib/antlr-3.0b7.jar:/usr/local/antlr/lib/antlr-2.7.7.jar"
export CLASSPATH="$CLASSPATH:/usr/local/antlr/lib/stringtemplate-3.0.jar"</pre>

= Building =

== Compiling the grammar ==

Given a grammar file, <tt>Walrus.g</tt>:

<pre>java org.antlr.Tool Walrus.g</pre>

Produces the following files:

* <tt>Walrus.tokens</tt>
* <tt>WalrusLexer.c</tt>
* <tt>WalrusLexer.h</tt>
* <tt>WalrusParser.c</tt>
* <tt>WalrusParser.h</tt>
* <tt>Walrus__.g</tt>

The lexer header contains information about how to actually use it; for example, an extremely simple lexer with only a few different token types yields:

<pre> * The lexer WalrusLexerhas the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pWalrusLexer, which is returned from a call to WalrusLexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the entry points are provided anyway.
 * * The entry points for WalrusLexer are  as follows:
 *
 *  - void      pWalrusLexer->SPECIAL_CHAR(pWalrusLexer)
 *  - void      pWalrusLexer->RAW_TEXT(pWalrusLexer)
 *  - void      pWalrusLexer->WALRUS_ESCAPE_SEQUENCE(pWalrusLexer)
 *  - void      pWalrusLexer->Tokens(pWalrusLexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.</pre>

And here is the parser header for an extremely simple parser with only one rule:

<pre> * The parser WalrusParserhas the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pWalrusParser, which is returned from a call to WalrusParserNew().
 *
 * The entry points for WalrusParser are  as follows:
 *
 *  - WalrusParser_anything_return      pWalrusParser->anything(pWalrusParser)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.</pre>

== Compiling the generated C code ==

=== Prerequisites ===

The generated files <tt>#include</tt> the file, <tt>antlr3.h</tt> (on my system located at <tt>/usr/local/antlr-3.0b7/lib/C/include/antlr3.h</tt>).

At least in 3.0b7 the [[ANTLR]] C runtime libraries are not shipped in binary form anywhere that I know of, so you have to build and install them first.

<pre># from top-level of expanded ANTLR distribution tarball
cd lib/C/dist
tar xzvf libantlr3c-3.0.0-rc7.tar.gz
cd libantlr3c-3.0.0-rc7
./configure
make
make check # (currently does nothing)
sudo make install</pre>

This installs the following libraries:

* <tt>/usr/local/lib/libantlr3c.dylib</tt>
* <tt>/usr/local/lib/libantlr3c.la</tt>
* <tt>/usr/local/lib/libantlr3c.a</tt>

As well as the headers in <tt>/usr/local/include/</tt>:

* <tt>/usr/local/include/antlr3.h</tt> (and various others)

Technically, I think it would be more correct if these were installed in <tt>/usr/local/lib/antlr/</tt> because there are quite a few of them.

=== Compiling ===

To compile the lexer, parser and link to the <tt>libantlr3c</tt> runtime library:

<pre>gcc -Wall main.c WalrusLexer.c WalrusParser.c -lantlr3c -o walrus_parser</pre>

A <tt>main.c</tt> file is required because otherwise the linker will complain about a missing <tt>_main</tt> symbol. The simplest possible example (which does nothing) is this:

<pre>int main(int argc, char *argv[])
{
    return 0;
}</pre>

Now an example which actually does something:

* Initialize a stream from a string at runtime
* Check for errors
* Manually invoke the lexer and print tokens one at a time
* Invoke the parser (commented out; comment out the lexer instead to see what happens)

<pre>#import "WalrusLexer.h"
#import "WalrusParser.h"

int main(int argc, char *argv[])
{
    pANTLR3_UINT8               input_string = "hello world";
    pANTLR3_INPUT_STREAM        stream = antlr3NewAsciiStringInPlaceStream(input_string, strlen(input_string), "input text stream");
    
    if (stream == (pANTLR3_INPUT_STREAM)ANTLR3_ERR_NOMEM)
    {
      fprintf(stderr, "no memory\n");
      exit(EXIT_FAILURE);
    }
    else if (stream == (pANTLR3_INPUT_STREAM)ANTLR3_ERR_NOFILE)
    {
      fprintf(stderr, "file not found\n");
      exit(EXIT_FAILURE);
    }
    
    pWalrusLexer                lexer  = WalrusLexerNew(stream);
    pANTLR3_COMMON_TOKEN_STREAM	tokens = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, lexer->pLexer->tokSource);
    
    pANTLR3_COMMON_TOKEN        token;
    while ((token = tokens->tstream->LT(tokens->tstream, 1))->getType(token) != ANTLR3_TOKEN_EOF)
    {
      printf("Token: %s\n", token->toString(token)->chars);
      tokens->tstream->istream->consume(tokens->tstream->istream);
    }
        
    /*pWalrusParser               parser = WalrusParserNew(tokens);
    parser->anything(parser);*/
    return 0;
}</pre>

The example does compile with some warnings:

<pre>main.c:6: warning: pointer targets in initialization differ in signedness
main.c:7: warning: pointer targets in passing argument 1 of ‘strlen’ differ in signedness
main.c:7: warning: pointer targets in passing argument 3 of ‘antlr3NewAsciiStringInPlaceStream’ differ in signedness</pre>

= Grammar details =

== To insert material at the top of the parser file ==

For example, to include a header file, you would place something like this after the <tt>options</tt> block:

<pre>@header {
#include <ruby.h>
}</pre>

Obviously, for this to work you would need to pass the appropriate include path to [[GCC]] via the <tt>-I</tt> switch.

== To insert material at the top of the lexer implementation ==

<pre>*@lexer::header {
#include <ruby.h>
}</pre>

== The <tt>@members</tt> section ==

Given that [[C]] is not [[object-oriented]] it doesn't make much sense to use a <tt>@members</tt> section when using the [[C language target]]. If you do use it, you will wind up with a file-scoped variable that will be inserted about half-way down the generated file; in that case, if you want file-scoped variables then you may as well just stick them in the <tt>@header</tt> section anyway.

However, if you want to include a helper function that can be called by any of your actions then the <tt>@members</tt> section may indeed be the best place to put it.

== The <tt>@declarations</tt> and <tt>@init</tt> sections ==

Each rule (lexer or parser rule) compiles down to a single function. The <tt>@declarations</tt> and <tt>@init</tt> sections allow you to declare variables that will be local to a given function and then initialize them. By performing the declaration and initialization in separate sections the generated should be very portable (for example, without using [[C99]] mode).

=== Example ===

<pre>foo
@declarations { int bar; }
@init { bar = 10; } :
A_TOKEN;</pre>

[[ANTLR]] will generate a function for parsing the <tt>foo</tt> rule. <tt>int bar;</tt> will appear near the top of the generated function, after the other variables in the function are declared. <tt>bar = 10;</tt> will appear a little further down, after the other variabels in the function are initialized.
